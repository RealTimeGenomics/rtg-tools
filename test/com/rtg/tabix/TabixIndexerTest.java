/*
 * Copyright (c) 2014. Real Time Genomics Limited.
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the
 *    distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.rtg.tabix;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

import com.rtg.tabix.TabixIndexer.BedIndexerFactory;
import com.rtg.tabix.TabixIndexer.TabixOptions;
import com.rtg.tabix.TabixIndexer.TsvIndexerFactory;
import com.rtg.util.Resources;
import com.rtg.util.io.FileUtils;
import com.rtg.util.io.IOUtils;
import com.rtg.util.io.TestDirectory;
import com.rtg.util.test.BgzipFileHelper;
import com.rtg.util.test.FileHelper;

import htsjdk.samtools.util.BlockCompressedInputStream;

import junit.framework.TestCase;

/**
 * Test class
 */
public class TabixIndexerTest extends TestCase {
  private File mDir;
  @Override
  public void setUp() throws IOException {
    mDir = FileUtils.createTempDir("tabix", "test");
  }

  @Override
  public void tearDown() {
    assertTrue(FileHelper.deleteAll(mDir));
    mDir = null;
  }

  private File file(String name) {
    return new File(mDir, name);
  }

  //avoid unclosed streams and try/finally blocks
  private InputStream lazyStream(File f) throws IOException {
    final byte[] data = IOUtils.readData(f);
    return new ByteArrayInputStream(data);
  }

  public void test() throws Exception {
    final File index = file("index");
    final File sam = FileHelper.resourceToFile("com/rtg/sam/resources/test.sam.gz", file("test.sam.gz"));
    new TabixIndexer(sam, index).saveSamIndex();
    final String myBai = IndexTestUtils.tbiIndexToUniqueString(new BlockCompressedInputStream(lazyStream(index)));
    final String exp;
    try (InputStream baiIs = new BlockCompressedInputStream(Resources.getResourceAsStream("com/rtg/sam/resources/test.sam.gz.tbi"))) {
      exp = IndexTestUtils.tbiIndexToUniqueString(baiIs);
    }

    assertEquals(exp, myBai);
  }

  public void testUnordered() throws Exception {
    final File dir = FileHelper.createTempDirectory();
    try {
      final File in = BgzipFileHelper.resourceToBgzipFile("com/rtg/sam/resources/unmated-out-of-order.sam", new File(dir, "unmated-out-of-order.sam.gz"));
      final File tabixFile = new File(in.getPath() + ".tbi");
      try {
        new TabixIndexer(in, tabixFile).saveSamIndex();
        fail();
      } catch (UnindexableDataException e) {
        assertFalse(tabixFile.exists());
        assertEquals("File is not sorted", e.getMessage());
      }
    } finally {
      assertTrue(FileHelper.deleteAll(dir));
    }
  }

  //the expected file here is not generated by tabix because the bug we are testing for hasn't been fixed in the c-tabix codebase
  public void testLinearIndexBug() throws Exception {
    final File index = file("index");
    final File input = FileHelper.resourceToFile("com/rtg/sam/resources/tabix.sam.gz", file("tabix.sam.gz"));
    new TabixIndexer(input, index).saveSamIndex();
    final String myBai = IndexTestUtils.tbiIndexToUniqueString(new BlockCompressedInputStream(lazyStream(index)));
    final String exp;
    try (InputStream baiIs = new BlockCompressedInputStream(Resources.getResourceAsStream("com/rtg/sam/resources/tabix.sam.gz.tbi"))) {
      exp = IndexTestUtils.tbiIndexToUniqueString(baiIs);
    }

    assertEquals(exp, myBai);
  }

  public void testLinearIndexOk() throws Exception {
    final File index = file("index");
    final File input = FileHelper.resourceToFile("com/rtg/sam/resources/tabixheader.sam.gz", file("tabixheader.sam.gz"));
    new TabixIndexer(input, index).saveSamIndex();
    final String myBai = IndexTestUtils.tbiIndexToUniqueString(new BlockCompressedInputStream(lazyStream(index)));
    final String exp;
    try (InputStream baiIs = new BlockCompressedInputStream(Resources.getResourceAsStream("com/rtg/sam/resources/tabixheader.sam.gz.tbi"))) {
      exp = IndexTestUtils.tbiIndexToUniqueString(baiIs);
    }

    assertEquals(exp, myBai);
  }

  //tests a mixed file of mapped and unmapped
  public void testMixed() throws Exception {
    final File index = file("index");
    final File input = FileHelper.resourceToFile("com/rtg/sam/resources/mixed.sam.gz", file("mixed.sam.gz"));
    new TabixIndexer(input, index).saveSamIndex();

    final String myBai = IndexTestUtils.tbiIndexToUniqueString(new BlockCompressedInputStream(lazyStream(index)));
    final String exp;
    try (InputStream baiIs = new BlockCompressedInputStream(Resources.getResourceAsStream("com/rtg/sam/resources/mixed.sam.gz.tbi"))) {
      exp = IndexTestUtils.tbiIndexToUniqueString(baiIs);
    }

    assertEquals(exp, myBai);
  }

  public void testLargish() throws Exception {
    final File index = file("index");
    final File input = FileHelper.resourceToFile("com/rtg/sam/resources/mmmm.sam.gz", file("mmmm.sam.gz"));
    new TabixIndexer(input, index).saveSamIndex();
    final String myBai = IndexTestUtils.tbiIndexToUniqueString(new BlockCompressedInputStream(lazyStream(index)));
    final String exp;
    try (InputStream baiIs = new BlockCompressedInputStream(Resources.getResourceAsStream("com/rtg/sam/resources/mmmm.sam.gz.tbi"))) {
      exp = IndexTestUtils.tbiIndexToUniqueString(baiIs);
    }

    assertEquals(exp, myBai);
  }

  public void testVcf() throws Exception {
    final File index = file("index");
    final File input = FileHelper.resourceToFile("com/rtg/sam/resources/vcf.txt.gz", file("vcf.txt.gz"));
    new TabixIndexer(input, index).saveVcfIndex();
    final String myBai = IndexTestUtils.tbiIndexToUniqueString(new BlockCompressedInputStream(lazyStream(index)));
    final String exp;
    try (InputStream baiIs = new BlockCompressedInputStream(Resources.getResourceAsStream("com/rtg/sam/resources/vcf.txt.gz.tbi"))) {
      exp = IndexTestUtils.tbiIndexToUniqueString(baiIs);
    }

    assertEquals(exp, myBai);
  }

  public void testFactories() throws Exception {

    final TsvIndexerFactory tif = new TabixIndexer.TsvIndexerFactory();
    TabixOptions options = tif.getOptions();
    assertEquals(TabixOptions.FORMAT_GENERIC, options.mFormat);
    assertEquals(0, options.mSeqCol);
    assertEquals(1, options.mStartCol);
    assertEquals(1, options.mEndCol);
    assertEquals('#', options.mMeta);
    assertEquals(0, options.mSkip);
    assertFalse(options.mZeroBased);
    ByteArrayOutputStream os = new ByteArrayOutputStream();
    try {
      try (InputStream is = Resources.getResourceAsStream("com/rtg/sam/resources/mmmm.sam.gz")) {
        assertNotNull(tif.getReader(is));
      }
    } finally {
      os.close();
    }

    final BedIndexerFactory bif = new TabixIndexer.BedIndexerFactory(0);
    options = bif.getOptions();
    assertEquals(TabixOptions.FORMAT_GENERIC | 0x10000, options.mFormat);
    assertEquals(0, options.mSeqCol);
    assertEquals(1, options.mStartCol);
    assertEquals(2, options.mEndCol);
    assertEquals('#', options.mMeta);
    assertEquals(0, options.mSkip);
    assertTrue(options.mZeroBased);
    os = new ByteArrayOutputStream();
    try {
      try (InputStream is = Resources.getResourceAsStream("com/rtg/sam/resources/mmmm.sam.gz")) {
        assertNotNull(bif.getReader(is));
      }
    } finally {
      os.close();
    }
  }

  public void testIsBedSkipLine() {
    assertTrue(TabixIndexer.isBedSkipLine("track type=bedGraph description=foo"));
    assertTrue(TabixIndexer.isBedSkipLine("track\ttype=bedGraph\tdescription=foo"));
    assertTrue(TabixIndexer.isBedSkipLine("#whatever man"));
    assertTrue(TabixIndexer.isBedSkipLine("browser "));
    assertFalse(TabixIndexer.isBedSkipLine("simulatedSequence1 0  6  2"));
    assertFalse(TabixIndexer.isBedSkipLine("simulatedSequence1 0 6 2"));
    assertFalse(TabixIndexer.isBedSkipLine("simulatedSequence1\t0\t6\t2"));
    assertFalse(TabixIndexer.isBedSkipLine("tracks 0 6 2"));
    assertFalse(TabixIndexer.isBedSkipLine("track17 0 6 2"));
    assertFalse(TabixIndexer.isBedSkipLine("track"));
  }

  public void testEmptyFileAsInput() throws IOException, UnindexableDataException {
    final File f = FileUtils.createTempDir("temp", "tabixindextest");
    try {
      final File file = new File(f, "regions.bed.gz");
      final OutputStream o = FileUtils.createOutputStream(file, true, false, true);
      o.close();
      new TabixIndexer(file, new File(file.getParent(), file.getName() + TabixIndexer.TABIX_EXTENSION)).saveBedIndex();
    } finally {
      assertTrue(FileHelper.deleteAll(f));
    }
  }

  public void testZeroLength() throws Exception {
    try (TestDirectory td = new TestDirectory()) {
      final File blankFile = new File(td, "blank");
      assertTrue(blankFile.createNewFile());

      final File indexOutFile = new File(td, blankFile.getName() + TabixIndexer.TABIX_EXTENSION);

      new TabixIndexer(blankFile, indexOutFile).saveVcfIndex();

      final String idx = FileHelper.gzFileToString(indexOutFile);
      assertEquals("TBI\u0001"
                 + "\u0000\u0000\u0000\u0000"
                 + "\u0002\u0000\u0000\u0000"
                 + "\u0001\u0000\u0000\u0000"
                 + "\u0002\u0000\u0000\u0000"
                 + "\u0000\u0000\u0000\u0000"
                 + "#"
                 + "\u0000\u0000\u0000\u0000"
                 + "\u0000\u0000\u0000\u0000"
                 + "\u0000\u0000\u0000", idx);
    }
  }
}
